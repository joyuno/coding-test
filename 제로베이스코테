def solution(phrases):
    answers=[]
    for i in range(len(phrases)):
        answer = phrases[i]
        last_word = answer.split(" ")[-1]
        if len(answer.split(" ")) ==1:
            answers.append(last_word)
        for j in range(len(phrases)):
            if i !=j:
                first_word = phrases[j].split(" ")[0]
                if first_word == last_word:
                    answer +=(" "+ " ".join(phrases[j].split(" ")[1:]))
                    answers.append(answer)
    return answers

    def solution(x, y):
    answer = 0
    y_dict = {item[0]: item[1] for item in y}

    answer = sum(x_item[1] * y_dict[x_item[0]] for x_item in x if x_item[0] in y_dict)
    return answer

import re
def solution(s):
    has_lowercase = any(c.islower() for c in s)  # 소문자 포함 여부
    has_uppercase = any(c.isupper() for c in s)  # 대문자 포함 여부
    has_digit = any(c.isdigit() for c in s)      # 숫자 포함 여부
    has_special = any(c in "!@#$%^&*(),.?\":{}|<>" for c in s)  # 특수문자 포함 여부
    is_valid_length = 6 <= len(s) <= 20 
    is_alphabet_sequential = any(
        ord(s[i+1].lower()) == ord(s[i].lower()) + 1 and
        ord(s[i+2].lower()) == ord(s[i+1].lower()) + 1
        for i in range(len(s) - 2) if s[i].isalpha()
    )

    # 연속된 3개 이상의 숫자 확인
    is_number_sequential = any(
        ord(s[i+1]) == ord(s[i]) + 1 and
        ord(s[i+2]) == ord(s[i+1]) + 1
        for i in range(len(s) - 2) if s[i].isdigit()
    )

    answer = all([has_lowercase,has_uppercase,has_special,has_digit,is_valid_length, not is_alphabet_sequential, not is_number_sequential])
    return answer

    for i in range(1, len(buckets)):
        if buckets[i] - last_position >= min_dist:
            count += 1  
            last_position = buckets[i]
            if count == m:  
                return True
    return False

def solution(buckets, m):
    buckets.sort() 

    # 이진 탐색 범위 설정
    left = 1  # 최소 거리
    right = buckets[-1] - buckets[0]  # 최대 거리
    answer = 0

    while left <= right:
        mid = (left + right) // 2  # 중간 거리
        if can_place_balls(buckets, m, mid):
            answer = mid  # 최소 거리 갱신
            left = mid + 1  # 더 큰 최소 거리를 탐색
        else:
            right = mid - 1  # 더 작은 최소 거리를 탐색

    return answer

def solution(s, k):
    stack = []

    for digit in s:
        # 스택의 마지막 숫자가 현재 숫자보다 크고, 제거할 기회(K)가 남아있으면 제거
        while stack and k > 0 and stack[-1] > digit:
            stack.pop()
            k -= 1
        stack.append(digit)

    # 제거할 문자가 남아있으면 뒤에서 추가로 제거
    stack = stack[:-k] if k > 0 else stack

    # 결과를 문자열로 변환하고, 앞의 0 제거
    answer = ''.join(stack).lstrip('0')

    return answer if answer else "0"

import math
def solution(N, M):
    #short_side, long_side = (M,N) if N>=M else (N,M)
    #answer = math.ceil(long_side / short_side) * short_side
    gcd = math.gcd(N,M)
    answer = N+M-gcd
    return answer
